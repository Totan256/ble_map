
#pragma kernel CSMain
#pragma kernel CSClear
///*
struct GPUDeviceSample
{
    float rssi;
    float2 worldPosition;
    float4 color;
};

StructuredBuffer<GPUDeviceSample> _Samples;
int _SampleCount;
float _MeasuredPower;
float _EnvironmentalFactor;
//*/
float2 _MapSize;
float2 _CurrentPosition; // 自分の現在地(GPSなど)
float _ZoomLevel; // 表示範囲（例：0.001で約110m四方）
RWTexture2D<float4> _Result;

// 蓄積用のテクスチャを真っ黒（透明）にクリアするカーネル
[numthreads(8, 8, 1)]
void CSClear(uint3 id : SV_DispatchThreadID)
{
    _Result[id.xy] = float4(0, 0, 0, 1);
}

/*
[numthreads(8, 8, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    // 計算を全部無視して、純粋な「赤」を書き込む
    float2 pixelPos = (float2) id.xy / _MapSize;
    _Result[id.xy] = float4(pixelPos, 1, 1);
}
//*/
///*

// BleDistanceMap.compute 内
[numthreads(8, 8, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    float2 uv = (float2) id.xy / _MapSize;
    float2 worldPixelPos = _CurrentPosition + (uv - 0.5) * _ZoomLevel;

    
    float intensity = 0;
    float4 baseColor = float4(0, 0, 0, 1);

    for (int i = 0; i < _SampleCount; i++)
    {
        // dはメートル単位
        float d = pow(10, (_MeasuredPower - _Samples[i].rssi) / (10 * _EnvironmentalFactor));
        
        // worldPositionもメートル単位で送られてくるので、そのまま計算可能
        float distToSample = distance(worldPixelPos, _Samples[i].worldPosition);
        
        // 0.2m 程度のボケ幅でリングを描画
        intensity += exp(-pow(distToSample - d, 2) / 0.04);
        
        //if (distToSample < d)
        {
            baseColor = baseColor + _Samples[i].color * intensity;
        }
    }
    
    // 赤色成分に強度を乗せる、あるいは合成
    _Result[id.xy] += baseColor;
    _Result[id.xy] = min(float4(1, 1, 1, 1), _Result[id.xy]);

}
//*/